<#@ template language="VB" debug="false" hostspecific="true"#>
<#@ include file="EF.Utility.VB.ttinclude"#><#@
 output extension=".vb"#><#
' Copyright (c) Microsoft Corporation.  All rights reserved.

Dim code As New CodeGenerationTools(Me)
Dim loader As New MetadataLoader(Me)
Dim region As New CodeRegion(Me)
Dim ef As New MetadataTools(Me)

Dim inputFile As String = "LadisacModel.edmx"
Dim metadataWorkspace As MetadataWorkspace = Nothing
Dim allMetadataLoaded As Boolean = loader.TryLoadAllMetadata(inputFile, metadataWorkspace)
Dim ItemCollection As EdmItemCollection = DirectCast(metadataWorkspace.GetItemCollection(DataSpace.CSpace), EdmItemCollection)
Dim originalValueMembers As New OriginalValueMembers(allMetadataLoaded, metadataWorkspace, ef)
Dim namespaceName As String = code.VsNamespaceSuggestion()

Dim fileManager As EntityFrameworkTemplateFileManager = EntityFrameworkTemplateFileManager.Create(Me)

' Escribir el código auxiliar en el archivo de salida de plantilla principal
WriteHeader(fileManager)
BeginNamespace(namespaceName, code)
WriteObjectChangeTracker()
WriteIObjectWithChangeTracker()
WriteCustomObservableCollection()
WriteINotifyComplexPropertyChanging()
WriteEqualityComparer()
EndNamespace(namespaceName)

' Emitir tipos de entidad
For Each loopEntity As EntityType In ItemCollection.GetItems(Of EntityType)().OrderBy(Function(e) e.Name)
    Dim entity As EntityType = loopEntity
    fileManager.StartNewFile(entity.Name & ".vb")
    BeginNamespace(namespaceName, code)
    WriteEntityTypeSerializationInfo(entity, ItemCollection, code, ef)
#>
Partial <#=Accessibility.ForType(entity)#> <#=code.SpaceAfter(code.MustInheritOption(entity))#>Class <#=code.Escape(entity)#><#=code.StringBefore(Environment.NewLine & CodeRegion.GetIndent(region.CurrentIndentLevel + 2) & "Inherits ", code.Escape(entity.BaseType))#>
    Implements IObjectWithChangeTracker
    Implements INotifyPropertyChanged

<#
    region.Begin("Propiedades primitivas")#>


	<DataContract()> Partial Public Structure PropertyNames
		<# For Each edmProperty As EdmProperty In entity.Properties.Where(Function(p) TypeOf p.TypeUsage.EdmType Is PrimitiveType AndAlso p.DeclaringType Is entity)#>
		public shared <#=code.Escape(edmProperty)#> As string = "<#=code.Escape(edmProperty)#>"
		<# Next #>
    End Structure
	


<# For Each edmProperty As EdmProperty In entity.Properties.Where(Function(p) TypeOf p.TypeUsage.EdmType Is PrimitiveType AndAlso p.DeclaringType Is entity)#>

    <DataMember()>
    <#=Accessibility.ForProperty(edmProperty)#> Property <#=code.Escape(edmProperty)#>() As <#=code.Escape(edmProperty.TypeUsage)#>
        Get
            Return <#=code.FieldName(edmProperty)#>
        End Get
        Set(ByVal value As <#=code.Escape(edmProperty.TypeUsage)#>)
<#
        If DirectCast(edmProperty.TypeUsage.EdmType, PrimitiveType).PrimitiveTypeKind = PrimitiveTypeKind.Binary Then
            Dim edmPropertyTemp As EdmProperty = edmProperty
            If ef.IsKey(edmPropertyTemp) OrElse entity.NavigationProperties.Where(Function(np) np.GetDependentProperties().Contains(edmPropertyTemp)).Any() Then
#>
            If Not EqualityComparer.BinaryEquals(<#=code.FieldName(edmProperty)#>, value) Then
<#
            Else
#>
            If <#=code.FieldName(edmProperty)#> IsNot value Then
<#
            End If
        Else
#>
            If Not Equals(<#=code.FieldName(edmProperty)#>, value) Then
<#
        End If

        If ef.IsKey(edmProperty) Then
            Dim errorMessage As String = String.Format(
                "La propiedad '{0}' forma parte de la clave del objeto y no se puede modificar. Solo se pueden realizar cambios en las propiedades de clave cuando no se realiza un seguimiento del objeto o su estado es Agregado.",
                edmProperty.Name)
#>
                If ChangeTracker.ChangeTrackingEnabled AndAlso ChangeTracker.State <> ObjectState.Added Then
                    Throw New InvalidOperationException("<#=errorMessage#>")
                End If
<#
        ElseIf originalValueMembers.IsOriginalValueMember(edmProperty) Then
#>
                ChangeTracker.RecordOriginalValue("<#=edmProperty.Name#>", <#=code.FieldName(edmProperty)#>)
<#
        End If

        Dim ep As EdmProperty = edmProperty
        Dim hasDependentProperties As Boolean = entity.NavigationProperties.Where(Function(p) p.GetDependentProperties().Contains(ep)).Any()
        If hasDependentProperties Then
#>
                If Not IsDeserializing Then
<#
        End If
        For Each np As NavigationProperty In entity.NavigationProperties.Where(Function(p) p.GetDependentProperties().Contains(ep))

            Dim principalProperty As EdmProperty = ef.GetCorrespondingPrincipalProperty(np, edmProperty)
            Dim equality As String = If(DirectCast(principalProperty.TypeUsage.EdmType, PrimitiveType).PrimitiveTypeKind = PrimitiveTypeKind.Binary, "EqualityComparer.Binary", String.Empty)
#>
                    If <#=code.Escape(np)#> IsNot Nothing AndAlso Not <#=equality#>Equals(<#=code.Escape(np)#>.<#=code.Escape(principalProperty)#>, value) Then
<#
            If Not (np.GetDependentProperties().Where(Function(p) ef.IsNullable(p)).Any() AndAlso np.GetDependentProperties().Count() > 1) Then
#>
                        <#=code.Escape(np)#> = Nothing
<#
            Else
#>
                        Dim previousValue As <#=code.Escape(np.TypeUsage)#> = <#=code.FieldName(np)#>
                        <#=code.FieldName(np)#> = Nothing
                        Fixup<#=np.Name#>(previousValue, skipKeys:=True)
                        OnNavigationPropertyChanged("<#=np.Name#>")
<#
            End If
#>
                    End If
<#
        Next
        If hasDependentProperties Then
#>
                End If
<#
        End If
#>
                <#=code.FieldName(edmProperty)#> = value
                OnPropertyChanged("<#=edmProperty.Name#>")
            End If
        End Set
    End Property

    Private <#=code.FieldName(edmProperty)#> As <#=code.Escape(edmProperty.TypeUsage)#><#=code.StringBefore(" = ", code.CreateLiteral(edmProperty.DefaultValue))#>
<#
    Next
    region.End()

    region.Begin("Propiedades complejas")
    For Each edmProperty As EdmProperty In entity.Properties.Where(Function(p) TypeOf p.TypeUsage.EdmType Is ComplexType AndAlso p.DeclaringType Is entity)
#>

    <DataMember()>
    <#=Accessibility.ForProperty(edmProperty)#> Property <#=code.Escape(edmProperty)#>() As <#=code.Escape(edmProperty.TypeUsage)#>
        <#=code.SpaceAfter(Accessibility.ForGetter(edmProperty))#>Get
            If Not <#=InitializedTrackingField(edmProperty, code)#> AndAlso <#=code.FieldName(edmProperty)#> Is Nothing Then
                <#=code.FieldName(edmProperty)#> = New <#=code.Escape(edmProperty.TypeUsage)#>()
                AddHandler DirectCast(<#=code.FieldName(edmProperty)#>, INotifyComplexPropertyChanging).ComplexPropertyChanging, AddressOf Handle<#=edmProperty.Name#>Changing
            End If
            <#=InitializedTrackingField(edmProperty, code)#> = True
            Return <#=code.FieldName(edmProperty)#>
        End Get
        Set(ByVal value As <#=code.Escape(edmProperty.TypeUsage)#>)
            <#=InitializedTrackingField(edmProperty, code)#> = True
            If Not Equals(<#=code.FieldName(edmProperty)#>, value) Then
                If <#=code.FieldName(edmProperty)#> IsNot Nothing Then
                    RemoveHandler DirectCast(<#=code.FieldName(edmProperty)#>, INotifyComplexPropertyChanging).ComplexPropertyChanging, AddressOf Handle<#=edmProperty.Name#>Changing
                End If

                Handle<#=edmProperty.Name#>Changing(Me, Nothing)
                <#=code.FieldName(edmProperty)#> = value
                OnPropertyChanged("<#=edmProperty.Name#>")

                If value IsNot Nothing Then
                    AddHandler DirectCast(<#=code.FieldName(edmProperty)#>, INotifyComplexPropertyChanging).ComplexPropertyChanging, AddressOf Handle<#=edmProperty.Name#>Changing
                End If
            End If
        End Set
    End Property

    Private <#=code.FieldName(edmProperty)#> As <#=code.Escape(edmProperty.TypeUsage)#>
    Private <#=InitializedTrackingField(edmProperty, code)#> As Boolean
<#
    Next

    region.End()
    region.Begin("Propiedades de navegación")

    For Each navProperty As NavigationProperty In entity.NavigationProperties.Where(Function(np) np.DeclaringType Is entity)
        Dim inverse As NavigationProperty = ef.Inverse(navProperty)
        Dim fromType As EntityType = navProperty.FromEndMember.GetEntityType()
        Dim toType As EntityType = navProperty.ToEndMember.GetEntityType()
        If inverse IsNot Nothing AndAlso Not IsReadWriteAccessibleProperty(inverse) Then
            inverse = Nothing
        End If
#>

    <DataMember()>
<#
        If navProperty.ToEndMember.RelationshipMultiplicity = RelationshipMultiplicity.Many Then
#>
    <#=Accessibility.ForReadOnlyProperty(navProperty)#> Property <#=code.Escape(navProperty)#>() As TrackableCollection(Of <#=code.Escape(toType)#>)
        Get
            If <#=code.FieldName(navProperty)#> Is Nothing Then
                <#=code.FieldName(navProperty)#> = New TrackableCollection(Of <#=code.Escape(toType)#>)
                AddHandler <#=code.FieldName(navProperty)#>.CollectionChanged, AddressOf Fixup<#=navProperty.Name#>
            End If
            Return <#=code.FieldName(navProperty)#>
        End Get
        Set(ByVal value As TrackableCollection(Of <#=code.Escape(toType)#>))
            If Not Object.ReferenceEquals(<#=code.FieldName(navProperty)#>, value) Then
                If ChangeTracker.ChangeTrackingEnabled Then
                    Throw New InvalidOperationException("No se puede establecer el elemento FixupChangeTrackingCollection cuando se ha habilitado ChangeTracking")
                End If
                If <#=code.FieldName(navProperty)#> IsNot Nothing Then
                    RemoveHandler <#=code.FieldName(navProperty)#>.CollectionChanged, AddressOf Fixup<#=navProperty.Name#>
<#
        If ef.IsCascadeDeletePrincipal(navProperty) Then
#>
                    ' Este es el extremo principal en una asociación que realiza eliminaciones en cascada.
                    ' Quitar el controlador de eventos de la eliminación en cascada para aquellas entidades de la colección actual.
                    For Each item As <#=code.Escape(navProperty.ToEndMember.GetEntityType())#> In <#=code.FieldName(navProperty)#>
                        RemoveHandler ChangeTracker.ObjectStateChanging, AddressOf item.HandleCascadeDelete
                    Next
<#
        End If
#>
                End If
                <#=code.FieldName(navProperty)#> = value
                If <#=code.FieldName(navProperty)#> IsNot Nothing Then
                    AddHandler <#=code.FieldName(navProperty)#>.CollectionChanged, AddressOf Fixup<#=navProperty.Name#>
<#
        If ef.IsCascadeDeletePrincipal(navProperty) Then
#>
                    ' Este es el extremo principal en una asociación que realiza eliminaciones en cascada.
                    ' Agrega el controlador de eventos de eliminación en cascada para aquellas entidades que ya se encuentran en la nueva colección.
                    For Each item As <#=code.Escape(navProperty.ToEndMember.GetEntityType())#> In <#=code.FieldName(navProperty)#>
                        AddHandler ChangeTracker.ObjectStateChanging, AddressOf item.HandleCascadeDelete
                    Next
<#
        End If
#>
                End If
                OnNavigationPropertyChanged("<#=navProperty.Name#>")
            End If
        End Set
    End Property

    Private <#=code.FieldName(navProperty)#> As TrackableCollection(Of <#=code.Escape(toType)#>)
<#
        Else
#>
    <#=Accessibility.ForProperty(navProperty)#> Property <#=code.Escape(navProperty)#>() As <#=code.Escape(toType)#>
        <#=code.SpaceAfter(Accessibility.ForGetter(navProperty))#>Get
            Return <#=code.FieldName(navProperty)#>
        End Get
        <#=code.SpaceAfter(Accessibility.ForSetter(navProperty))#>Set(ByVal value As <#=code.Escape(toType)#>)
            If <#=code.FieldName(navProperty)#> IsNot value Then
<#
            ' Si este es el extremo dependiente de una relación de identificación, el extremo principal solo se puede cambiar si el extremo dependiente se encuentra en el estado agregado y la clave del extremo principal coincide con la clave externa del extremo dependiente
            If ef.IsPrincipalEndOfIdentifyingRelationship(DirectCast(navProperty.ToEndMember, AssociationEndMember)) Then
#>
                If ChangeTracker.ChangeTrackingEnabled AndAlso ChangeTracker.State <> ObjectState.Added AndAlso value IsNot Nothing Then
<#
                Dim dependents As List(Of EdmProperty) = navProperty.GetDependentProperties().ToList()
                Dim dependentCount As Integer = dependents.Count
                Dim keyMatchCondition As New StringBuilder()
                For i As Integer = 0 To dependentCount - 1
                    Dim dependentProperty As EdmProperty = dependents(i)
                    Dim principalProperty As EdmProperty = ef.GetCorrespondingPrincipalProperty(navProperty, dependentProperty)
                    Dim escapedDependent As String = code.Escape(dependentProperty)
                    Dim escapedPrincipal As String = code.Escape(principalProperty)

                    If i > 0 Then
                        keyMatchCondition.AppendFormat(" OrElse ")
                    End If

                    Dim equality As String = Nothing
                    If DirectCast(principalProperty.TypeUsage.EdmType, PrimitiveType).PrimitiveTypeKind = PrimitiveTypeKind.Binary Then
                        equality = "Not EqualityComparer.BinaryEquals({0}, value.{1})"
                    Else
                        equality = "Not Equals({0}, value.{1})"
                    End If
                    keyMatchCondition.AppendFormat(CultureInfo.InvariantCulture, equality, escapedDependent, escapedPrincipal)
                Next
#>
                    ' Este es el extremo dependiente de una relación de identificación por lo que el extremo principal no se puede cambiar si ya está establecido;
                    ' de lo contrario, solo se puede establecer en una entidad con una clave primaria que tenga el mismo valor que la clave externa del extremo dependiente.
                    If <#=keyMatchCondition.ToString()#> Then
                        Throw New InvalidOperationException("El extremo principal de una relación de identificación solo se puede modificar cuando el extremo dependiente se encuentra en el estado agregado.")
                    End If
                End If
<#
            End If
#>
                Dim previousValue As <#=code.Escape(toType)#> = <#=code.FieldName(navProperty)#>
                <#=code.FieldName(navProperty)#> = value
                Fixup<#=navProperty.Name#>(previousValue)
                OnNavigationPropertyChanged("<#=navProperty.Name#>")
            End If
        End Set
    End Property

    Private <#=code.FieldName(navProperty)#> As <#=code.Escape(navProperty.ToEndMember.GetEntityType())#>

<#
        End If
    Next
    region.End()
    region.Begin("ChangeTracking")

    If entity.BaseType Is Nothing Then
#>

    Protected Overridable Sub OnPropertyChanged(ByVal propertyName As String)
        If ChangeTracker.State <> ObjectState.Added AndAlso ChangeTracker.State <> ObjectState.Deleted Then
            ChangeTracker.State = ObjectState.Modified
        End If
        RaiseEvent PropertyChanged(Me, New PropertyChangedEventArgs(propertyName))
    End Sub

    Protected Overridable Sub OnNavigationPropertyChanged(ByVal propertyName As String)
        RaiseEvent PropertyChanged(Me, New PropertyChangedEventArgs(propertyName))
    End Sub

    Private Event PropertyChanged As PropertyChangedEventHandler Implements INotifyPropertyChanged.PropertyChanged
    Private _changeTracker As ObjectChangeTracker

    <DataMember()>
    Public Property ChangeTracker() As ObjectChangeTracker Implements IObjectWithChangeTracker.ChangeTracker
        Get
            If _changeTracker Is Nothing Then
                _changeTracker = New ObjectChangeTracker()
                AddHandler _changeTracker.ObjectStateChanging, AddressOf HandleObjectStateChanging
            End If
            Return _changeTracker
        End Get
        Set(ByVal value As ObjectChangeTracker)
            If _changeTracker IsNot Nothing Then
                RemoveHandler _changeTracker.ObjectStateChanging, AddressOf HandleObjectStateChanging
            End If
            _changeTracker = value
            If _changeTracker IsNot Nothing Then
                AddHandler _changeTracker.ObjectStateChanging, AddressOf HandleObjectStateChanging
            End If
        End Set
    End Property

    Private Sub HandleObjectStateChanging(ByVal sender As Object, ByVal e As ObjectStateChangingEventArgs)
        If e.NewState = ObjectState.Deleted Then
            Me.ClearNavigationProperties()
        End If
    End Sub
<#
    ' Si este tipo de entidad participa en relaciones donde el otro extremo tiene una eliminación en cascada OnDelete
    ' definida o si es el extremo dependiente de cualquier relación de identificación, necesita
    ' un controlador de eventos para controlar notificaciones que se desencadenan cuando el elemento primario se elimina.
    If ItemCollection.GetItems(Of AssociationType)().Where(
        Function(a) DirectCast(a.AssociationEndMembers(0).TypeUsage.EdmType, RefType).ElementType Is entity AndAlso ef.IsCascadeDeletePrincipal(a.AssociationEndMembers(1)) OrElse _
            DirectCast(a.AssociationEndMembers(1).TypeUsage.EdmType, RefType).ElementType Is entity AndAlso ef.IsCascadeDeletePrincipal(a.AssociationEndMembers(0))).Any() Then
#>

    ' Este tipo de entidad es el extremo dependiente en al menos una asociación que realiza eliminaciones en cascada.
    ' Este controlador de eventos procesará notificaciones que tienen lugar cuando se elimina el extremo principal.
    Friend Sub HandleCascadeDelete(ByVal sender As Object, ByVal e As ObjectStateChangingEventArgs)
        If e.NewState = ObjectState.Deleted Then
            Me.MarkAsDeleted()
        End If
    End Sub
<#
    End If
#>

    Private _isDeserializing As Boolean
    Protected Property IsDeserializing() As Boolean
        Get
            Return _isDeserializing
        End Get
        Private Set(ByVal value As Boolean)
            _isDeserializing = value
        End Set
    End Property

    <OnDeserializing()>
    Public Sub OnDeserializingMethod(ByVal context As StreamingContext)
        IsDeserializing = True
    End Sub

    <OnDeserialized()>
    Public Sub OnDeserializedMethod(ByVal context As StreamingContext)
        IsDeserializing = False
        ChangeTracker.ChangeTrackingEnabled = True
    End Sub
<#
    End If

    For Each edmProperty As EdmProperty In entity.Properties.Where(Function(p) TypeOf p.TypeUsage.EdmType Is ComplexType AndAlso p.DeclaringType Is entity)
#>
    ' <#=String.Format(CultureInfo.CurrentCulture, "Registra los valores originales de la propiedad compleja {0}", edmProperty.Name)#>
    Private Sub Handle<#=edmProperty.Name#>Changing(ByVal sender As Object, ByVal args As EventArgs)
        If ChangeTracker.State <> ObjectState.Added AndAlso ChangeTracker.State <> ObjectState.Deleted Then
            ChangeTracker.State = ObjectState.Modified
        End If
<#
        If originalValueMembers.IsOriginalValueMember(edmProperty) Then
#>
        <#=code.Escape(edmProperty.TypeUsage)#>.RecordComplexOriginalValues("<#=edmProperty.Name#>", Me.<#=code.Escape(edmProperty)#>, ChangeTracker)
<#
        End If
#>
    End Sub

<#
    Next
    Dim shadowAssociationEnds As New List(Of AssociationEndMember)()
    For Each association As AssociationType In ItemCollection.GetItems(Of AssociationType)().Where(Function(x As AssociationType) (Not IsForeignKeyOrIdentifyingRelationship(ef, x)) AndAlso _
                        ((Object.Equals(DirectCast(x.AssociationEndMembers(0).TypeUsage.EdmType, RefType).ElementType, entity) AndAlso _
                          x.AssociationEndMembers(0).RelationshipMultiplicity <> RelationshipMultiplicity.One AndAlso _
                          x.AssociationEndMembers(1).RelationshipMultiplicity <> RelationshipMultiplicity.Many) OrElse _
                         (Object.Equals(DirectCast(x.AssociationEndMembers(1).TypeUsage.EdmType, RefType).ElementType, entity) AndAlso _
                          x.AssociationEndMembers(1).RelationshipMultiplicity <> RelationshipMultiplicity.One AndAlso _
                          x.AssociationEndMembers(0).RelationshipMultiplicity <> RelationshipMultiplicity.Many)))
        Dim theAssociation As AssociationType = association
        If Not entity.NavigationProperties.Any(Function(x) Object.Equals(x.RelationshipType, theAssociation)) Then
            For i As Integer = 0 To 1
                Dim targetRoleIndex As Integer = 0
                If Object.Equals(DirectCast(theAssociation.AssociationEndMembers(i).TypeUsage.EdmType, RefType).ElementType, entity) Then
                    targetRoleIndex = (i + 1) Mod 2
                    shadowAssociationEnds.Add(theAssociation.AssociationEndMembers(targetRoleIndex))
                End If
            Next
        End If
    Next
#>

    Protected <#=InheritanceOperator(entity)#>Sub ClearNavigationProperties()
<#
    If entity.BaseType IsNot Nothing Then
#>
        MyBase.ClearNavigationProperties()
<#
    End If
    For Each navProperty As NavigationProperty In entity.NavigationProperties.Where(Function(np) np.DeclaringType Is entity)
        If navProperty.ToEndMember.RelationshipMultiplicity = RelationshipMultiplicity.Many Then
#>
        <#=code.Escape(navProperty)#>.Clear()
<#
        Else
#>
        <#=code.Escape(navProperty)#> = Nothing
<#
            If IsSaveReference(ef, navProperty) Then
#>
        Fixup<#=navProperty.Name#>Keys()
<#
            End If
        End If
    Next
    For Each associationEnd As AssociationEndMember In shadowAssociationEnds
        Dim association As AssociationType = TryCast(associationEnd.DeclaringType, AssociationType)
#>
        <#=CreateFixupMethodName(associationEnd)#>(Nothing, True)
<#

    Next
#>
    End Sub
<#
    region.End()

    region.Begin("Corrección de asociación")

    For Each navProperty As NavigationProperty In entity.NavigationProperties.Where(Function(np) np.DeclaringType Is entity)
        Dim inverse As NavigationProperty = ef.Inverse(navProperty)
        If inverse IsNot Nothing AndAlso Not IsReadWriteAccessibleProperty(inverse) Then
            inverse = Nothing
        End If

        If navProperty.ToEndMember.RelationshipMultiplicity <> RelationshipMultiplicity.Many Then
            Dim skipKeysArgument As String = If(navProperty.GetDependentProperties().Where(Function(p) ef.IsNullable(p)).Any(), ", Optional ByVal skipKeys As Boolean = False", String.Empty)
#>

    Private Sub Fixup<#=navProperty.Name#>(ByVal previousValue As <#=code.Escape(navProperty.ToEndMember.GetEntityType())#><#= skipKeysArgument #>)
<#
        If ef.IsCascadeDeletePrincipal(navProperty) Then
#>
        If previousValue IsNot Nothing Then
            RemoveHandler ChangeTracker.ObjectStateChanging, AddressOf previousValue.HandleCascadeDelete
        End If

        If <#=code.Escape(navProperty)#> IsNot Nothing Then
            AddHandler ChangeTracker.ObjectStateChanging, AddressOf <#=code.Escape(navProperty)#>.HandleCascadeDelete
        End If
<#
        ElseIf inverse Is Nothing AndAlso ef.IsCascadeDeletePrincipal(DirectCast(navProperty.ToEndMember, AssociationEndMember)) Then
#>
        ' Este es el extremo dependiente en una asociación que realiza eliminaciones en cascada.
        ' Actualizar la escucha de eventos del extremo principal para que se refiera al nuevo extremo dependiente.
        ' Esta es una relación unidireccional desde el extremo dependiente al extremo principal por lo que el extremo dependiente es
        ' responsable de administrar el controlador de eventos de eliminación en cascada. En el resto de los casos, será el extremo principal el que lo administrará.
        If previousValue IsNot Nothing Then
            RemoveHandler previousValue.ChangeTracker.ObjectStateChanging, AddressOf HandleCascadeDelete
        End If

        If <#=code.Escape(navProperty)#> IsNot Nothing Then
            AddHandler <#=code.Escape(navProperty)#>.ChangeTracker.ObjectStateChanging, AddressOf HandleCascadeDelete
        End If

<#
        End If
#>
        If IsDeserializing Then
            Return
        End If

<#
        If inverse IsNot Nothing Then
            If inverse.ToEndMember.RelationshipMultiplicity = RelationshipMultiplicity.Many Then
#>
        If previousValue IsNot Nothing AndAlso previousValue.<#=code.Escape(inverse)#>.Contains(Me) Then
            previousValue.<#=code.Escape(inverse)#>.Remove(Me)
        End If
<#
        Else
#>
        If previousValue IsNot Nothing AndAlso ReferenceEquals(previousValue.<#=code.Escape(inverse)#>, Me) Then
            previousValue.<#=code.Escape(inverse)#> = Nothing
        End If
<#
            End If

            If inverse.ToEndMember.RelationshipMultiplicity = RelationshipMultiplicity.Many Then
#>

        If <#=code.Escape(navProperty)#> IsNot Nothing Then
            If Not <#=code.Escape(navProperty)#>.<#=code.Escape(inverse)#>.Contains(Me) Then
                <#=code.Escape(navProperty)#>.<#=code.Escape(inverse)#>.Add(Me)
            End If

<#
                For Each dependentProperty As EdmProperty In navProperty.GetDependentProperties()
#>
            <#=code.Escape(dependentProperty)#> = <#=code.Escape(navProperty)#>.<#=code.Escape(ef.GetCorrespondingPrincipalProperty(navProperty, dependentProperty))#>
<#
                Next

                If navProperty.GetDependentProperties().Where(Function(p) ef.IsNullable(p)).Any() Then
#>
        ElseIf Not skipKeys Then
<#
                    For Each dependentProperty As EdmProperty In navProperty.GetDependentProperties().Where(Function(p) ef.IsNullable(p))
#>
            <#=code.Escape(dependentProperty)#> = Nothing
<#
                    Next
                End If
#>
        End If
<#
                Else
#>

        If <#=code.Escape(navProperty)#> IsNot Nothing Then
            <#=code.Escape(navProperty)#>.<#=code.Escape(inverse)#> = Me
<#
                For Each dependentProperty As EdmProperty In navProperty.GetDependentProperties()
#>
            <#=code.Escape(dependentProperty)#> = <#=code.Escape(navProperty)#>.<#=code.Escape(ef.GetCorrespondingPrincipalProperty(navProperty, dependentProperty))#>
<#
                Next
#>
        End If

<#
                End If
            Else
                If navProperty.GetDependentProperties().Any() Then
#>
        If <#=code.Escape(navProperty)#> IsNot Nothing Then
<#
                    For Each dependentProperty As EdmProperty In navProperty.GetDependentProperties()
#>
            <#=code.Escape(dependentProperty)#> = <#=code.Escape(navProperty)#>.<#=code.Escape(ef.GetCorrespondingPrincipalProperty(navProperty, dependentProperty))#>
<#
                    Next

                    If navProperty.GetDependentProperties().Where(Function(p) ef.IsNullable(p)).Any() Then
#>
        ElseIf Not skipKeys Then
<#
                        For Each dependentProperty As EdmProperty In navProperty.GetDependentProperties().Where(Function(p) ef.IsNullable(p))
#>
            <#=code.Escape(dependentProperty)#> = Nothing
<#
                        Next
                    End If
#>
        End If
<#
            ElseIf IsForeignKeyOrIdentifyingRelationship(ef, navProperty) Then
#>
        If <#=code.Escape(navProperty)#> IsNot Nothing Then
<#
                For Each fromProperty As EdmProperty In ef.GetPrincipalProperties(navProperty)
#>
            <#=code.Escape(navProperty)#>.<#=code.Escape(ef.GetCorrespondingDependentProperty(navProperty, fromProperty))#> = <#=code.Escape(fromProperty)#>
<#
                Next
#>
        End If

<#
            End If
        End If

#>
        If ChangeTracker.ChangeTrackingEnabled Then
            If ChangeTracker.OriginalValues.ContainsKey("<#=navProperty.Name#>") AndAlso
                ChangeTracker.OriginalValues("<#=navProperty.Name#>") Is <#=code.Escape(navProperty)#> Then
                ChangeTracker.OriginalValues.Remove("<#=navProperty.Name#>")
            Else
                ChangeTracker.RecordOriginalValue("<#=navProperty.Name#>", previousValue)
<#
        If ef.IsPrincipalEndOfIdentifyingRelationship(DirectCast(navProperty.FromEndMember, AssociationEndMember)) Then
#>
                ' Eliminar el extremo dependiente de esta asociación de identificación. Si el estado actual es agregado,
                ' permite que la relación se modifique sin eliminar el elemento dependiente.
                If previousValue IsNot Nothing AndAlso previousValue.ChangeTracker.State <> ObjectState.Added Then
                    previousValue.MarkAsDeleted()
                End If
<#
        ElseIf inverse Is Nothing AndAlso ef.IsPrincipalEndOfIdentifyingRelationship(DirectCast(navProperty.ToEndMember, AssociationEndMember)) Then
#>
                ' Este es el extremo dependiente de una asociación de identificación, por lo que se debe eliminar cuando la relación se
                ' elimine. Si el estado actual es agregado, la relación se puede modificar sin eliminar el extremo dependiente.
                ' Esta es una relación unidireccional desde el extremo dependiente al extremo principal por lo que el extremo dependiente es
                ' responsable de administrar en cascada la eliminación. En el resto de los casos, será el extremo principal el que lo administre.
                If previousValue IsNot Nothing AndAlso ChangeTracker.State <> ObjectState.Added Then
                    Me.MarkAsDeleted()
                End If
<#
        End If
#>
            End If
            If <#=code.Escape(navProperty)#> IsNot Nothing AndAlso Not <#=code.Escape(navProperty)#>.ChangeTracker.ChangeTrackingEnabled Then
                <#=code.Escape(navProperty)#>.StartTracking()
            End If
<#
        If IsSaveReference(ef, navProperty) Then
#>
            Fixup<#=navProperty.Name#>Keys()
<#
        End If
        If inverse Is Nothing AndAlso
            Not IsForeignKeyOrIdentifyingRelationship(ef, navProperty) AndAlso
            navProperty.FromEndMember.RelationshipMultiplicity <> RelationshipMultiplicity.Many AndAlso
            navProperty.ToEndMember.RelationshipMultiplicity <> RelationshipMultiplicity.One Then
#>
            If previousValue IsNot Nothing Then
                previousValue.<#=CreateFixupMethodName(navProperty.FromEndMember)#>(Nothing, False)
            End If
            If <#=code.Escape(navProperty)#> IsNot Nothing Then
                <#=code.Escape(navProperty)#>.<#=CreateFixupMethodName(navProperty.FromEndMember)#>(Me, False)
            End If
<#
        End If
#>
        End If
    End Sub
<#
        If IsSaveReference(ef, navProperty) Then
            Dim targetType As EntityType = DirectCast(navProperty.TypeUsage.EdmType, EntityType)
            Dim keyNames As List(Of String) = targetType.KeyMembers.Select(Function(x) x.Name).ToList()
#>
    Private Sub Fixup<#=navProperty.Name#>Keys()
<#
            For k As Integer = 0 To keyNames.Count - 1
#>
        Const <#=CreateKeyNameVariable(code.Escape(keyNames(k)))#> As String = "<#=CreateReferenceValueLookupKey(navProperty, keyNames(k))#>"
<#
            Next
#>

        If ChangeTracker.ExtendedProperties.ContainsKey(<#=CreateKeyNameVariable(code.Escape(keyNames(0)))#>)<#=If(keyNames.Count > 1, " AndAlso _", " Then")#>
<#
            For k As Integer = 1 To keyNames.Count - 1
#>
           ChangeTracker.ExtendedProperties.ContainsKey(<#=CreateKeyNameVariable(code.Escape(keyNames(k)))#>)<#=If(k < keyNames.Count - 1, " AndAlso _", " Then")#>
<#
            Next
#>
            If <#=code.Escape(navProperty)#> Is Nothing OrElse
<#
            For k As Integer = 0 To keyNames.Count - 1

                Dim equality As String = If(DirectCast(targetType.KeyMembers(keyNames(k)).TypeUsage.EdmType, PrimitiveType).PrimitiveTypeKind = PrimitiveTypeKind.Binary, "EqualityComparer.Binary", String.Empty)
#>
               Not <#=equality#>Equals(ChangeTracker.ExtendedProperties(<#=CreateKeyNameVariable(code.Escape(keyNames(k)))#>), <#=code.Escape(navProperty)#>.<#=code.Escape(keyNames(k))#>)<#=If(k < keyNames.Count - 1, " OrElse _", " Then")#>
<#
            Next
            For k As Integer = 0 To keyNames.Count - 1
#>
                ChangeTracker.RecordOriginalValue(<#=CreateKeyNameVariable(code.Escape(keyNames(k)))#>, ChangeTracker.ExtendedProperties(<#=CreateKeyNameVariable(code.Escape(keyNames(k)))#>))
<#
            Next
#>
            End If
<#
            For k As Integer = 0 To keyNames.Count - 1
#>
            ChangeTracker.ExtendedProperties.Remove(<#=CreateKeyNameVariable(code.Escape(keyNames(k)))#>)
<#
            Next
#>
        End If
    End Sub
<#
            End If
        End If
    Next

    For Each navProperty As NavigationProperty In entity.NavigationProperties.Where(Function(np) np.DeclaringType Is entity)
        Dim inverse As NavigationProperty = ef.Inverse(navProperty)
        If inverse IsNot Nothing AndAlso Not IsReadWriteAccessibleProperty(inverse) Then
            inverse = Nothing
        End If

        If navProperty.ToEndMember.RelationshipMultiplicity = RelationshipMultiplicity.Many Then
#>

    Private Sub Fixup<#=navProperty.Name#>(ByVal sender As Object, ByVal e As NotifyCollectionChangedEventArgs)
        If IsDeserializing Then
            Return
        End If

        If e.NewItems IsNot Nothing Then
            For Each item As <#=code.Escape(navProperty.ToEndMember.GetEntityType())#> In e.NewItems
<#
                If inverse IsNot Nothing Then
                    If inverse.ToEndMember.RelationshipMultiplicity <> RelationshipMultiplicity.Many Then
#>
                item.<#=code.Escape(inverse)#> = Me
<#
                    Else
#>
                If Not item.<#=code.Escape(inverse)#>.Contains(Me) Then
                    item.<#=code.Escape(inverse)#>.Add(Me)
                End If
<#
                    End If
                ElseIf IsForeignKeyOrIdentifyingRelationship(ef, navProperty) Then
                    For Each fromProperty As EdmProperty In ef.GetPrincipalProperties(navProperty)
#>
                item.<#=code.Escape(ef.GetCorrespondingDependentProperty(navProperty, fromProperty))#> = <#=code.Escape(fromProperty)#>
<#
                    Next
                ElseIf navProperty.FromEndMember.RelationshipMultiplicity = RelationshipMultiplicity.ZeroOrOne Then
#>
                item.<#=CreateFixupMethodName(navProperty.FromEndMember)#>(Me, False)
<#
                End If
#>
                If ChangeTracker.ChangeTrackingEnabled Then
                    If Not item.ChangeTracker.ChangeTrackingEnabled Then
                        item.StartTracking()
                    End If
                    ChangeTracker.RecordAdditionToCollectionProperties("<#=code.Escape(navProperty)#>", item)
                End If
<#
                If ef.IsCascadeDeletePrincipal(navProperty) Then
#>
                ' Este es el extremo principal en una asociación que realiza eliminaciones en cascada.
                ' Actualizar la escucha de eventos para que se refiera al nuevo extremo dependiente.
                AddHandler ChangeTracker.ObjectStateChanging, AddressOf item.HandleCascadeDelete
<#
                End If
#>
            Next
        End If

        If e.OldItems IsNot Nothing Then
            For Each item As <#=code.Escape(navProperty.ToEndMember.GetEntityType())#> In e.OldItems
<#
                If inverse IsNot Nothing Then
                    If inverse.ToEndMember.RelationshipMultiplicity <> RelationshipMultiplicity.Many Then
#>
                If ReferenceEquals(item.<#=code.Escape(inverse)#>, Me) Then
                    item.<#=code.Escape(inverse)#> = Nothing
                End If
<#
                    Else
#>
                If item.<#=code.Escape(inverse)#>.Contains(Me) Then
                    item.<#=code.Escape(inverse)#>.Remove(Me)
                End If
<#
                    End If
                ElseIf IsForeignKeyOrIdentifyingRelationship(ef, navProperty) Then
                    For Each fromProperty As EdmProperty In ef.GetPrincipalProperties(navProperty)
                        Dim p As EdmProperty = ef.GetCorrespondingDependentProperty(navProperty, fromProperty)
                        If ef.IsNullable(p.TypeUsage) Then
#>
                item.<#=code.Escape(p)#> = Nothing
<#
                        End If
                    Next
                ElseIf navProperty.FromEndMember.RelationshipMultiplicity = RelationshipMultiplicity.ZeroOrOne Then
#>
                item.<#=CreateFixupMethodName(navProperty.FromEndMember)#>(Nothing, False)
<#
                End If
#>
                If ChangeTracker.ChangeTrackingEnabled Then
                    ChangeTracker.RecordRemovalFromCollectionProperties("<#=code.Escape(navProperty)#>", item)
<#
                If ef.IsPrincipalEndOfIdentifyingRelationship(DirectCast(navProperty.FromEndMember, AssociationEndMember)) Then
#>
                    ' Eliminar el extremo dependiente de esta asociación de identificación. Si el estado actual es agregado,
                    ' permite que la relación se modifique sin eliminar el elemento dependiente.
                    If item.ChangeTracker.State <> ObjectState.Added Then
                        item.MarkAsDeleted()
                    End If
<#
                End If
#>
                End If
<#
                If ef.IsCascadeDeletePrincipal(navProperty) Then
#>
                ' Este es el extremo principal en una asociación que realiza eliminaciones en cascada.
                ' Quitar el extremo dependiente anterior de la escucha de eventos.
                RemoveHandler ChangeTracker.ObjectStateChanging, AddressOf item.HandleCascadeDelete
<#
                End If
#>
            Next
        End If
    End Sub
<#
        End If
    Next

    For Each associationEnd As AssociationEndMember In shadowAssociationEnds
        Dim association As AssociationType = TryCast(associationEnd.DeclaringType, AssociationType)
        Dim targetType As EntityType = TryCast(DirectCast(associationEnd.TypeUsage.EdmType, RefType).ElementType, EntityType)
        Dim keyNames As List(Of String) = targetType.KeyMembers.Select(Function(x) x.Name).ToList()
#>

    Friend Sub <#=CreateFixupMethodName(associationEnd)#>(ByVal value As <#=code.Escape(targetType)#>, ByVal forceRemove As Boolean)
<#
            For k As Integer = 0 To keyNames.Count - 1
#>
        Const <#=CreateKeyNameVariable(code.Escape(keyNames(k)))#> As String = "<#=CreateReferenceValueLookupKey(associationEnd, keyNames(k))#>"
<#
            Next
#>

        If ChangeTracker.ChangeTrackingEnabled AndAlso
<#
        For k As Integer = 0 To keyNames.Count - 1
#>
            ChangeTracker.ExtendedProperties.ContainsKey(<#=CreateKeyNameVariable(code.Escape(keyNames(k)))#>)<#=If(k < (keyNames.Count - 1), " AndAlso _", " Then")#>
<#
        Next
#>
            If forceRemove OrElse
<#
        For k As Integer = 0 To keyNames.Count - 1
            Dim equality As String = If(DirectCast(targetType.KeyMembers(keyNames(k)).TypeUsage.EdmType, PrimitiveType).PrimitiveTypeKind = PrimitiveTypeKind.Binary, "EqualityComparer.Binary", String.Empty)
#>
               Not <#=equality#>Equals(ChangeTracker.ExtendedProperties(<#=CreateKeyNameVariable(code.Escape(keyNames(k)))#>), If(value Is Nothing, Nothing, DirectCast(value.<#=code.Escape(keyNames(k))#>, Object)))<#=If(k < keyNames.Count - 1, " OrElse _", " Then")#>
<#
        Next
        For k As Integer = 0 To keyNames.Count - 1
#>
                ChangeTracker.RecordOriginalValue(<#=CreateKeyNameVariable(code.Escape(keyNames(k)))#>, ChangeTracker.ExtendedProperties(<#=CreateKeyNameVariable(code.Escape(keyNames(k)))#>))
<#
        Next
#>
                If value Is Nothing Then
<#
        For k As Integer = 0 To keyNames.Count - 1
#>
                    ChangeTracker.ExtendedProperties.Remove(<#=CreateKeyNameVariable(code.Escape(keyNames(k)))#>)
<#
        Next
#>
                Else
<#
        For k As Integer = 0 To keyNames.Count - 1
#>
                    ChangeTracker.ExtendedProperties(<#=CreateKeyNameVariable(code.Escape(keyNames(k)))#>) = value.<#=code.Escape(keyNames(k))#>
<#
        Next
#>
                End If
            End If
        End If
    End Sub
<#


    Next

    region.End()
#>
End Class
<#
    EndNamespace(namespaceName)
Next

' Emitir tipos complejos
For Each loopComplex As ComplexType In ItemCollection.GetItems(Of ComplexType)().OrderBy(Function(e) e.Name)
    Dim complex As ComplexType = loopComplex
    fileManager.StartNewFile(complex.Name & ".vb")
    BeginNamespace(namespaceName, code)

#>
Partial <#=Accessibility.ForType(complex)#> Class <#=code.Escape(complex)#>
    Implements INotifyComplexPropertyChanging
    Implements INotifyPropertyChanged

<#
    region.Begin("Propiedades primitivas")
    For Each edmProperty As EdmProperty In complex.Properties.Where(Function(p) TypeOf p.TypeUsage.EdmType Is PrimitiveType AndAlso p.DeclaringType Is complex)
#>

    <DataMember()>
    <#=Accessibility.ForProperty(edmProperty)#> Property <#=code.Escape(edmProperty)#>() As <#=code.Escape(edmProperty.TypeUsage)#>
        Get
            Return <#=code.FieldName(edmProperty)#>
        End Get
        Set(ByVal value As <#=code.Escape(edmProperty.TypeUsage)#>)
<#
        If DirectCast(edmProperty.TypeUsage.EdmType, PrimitiveType).PrimitiveTypeKind = PrimitiveTypeKind.Binary Then
#>
            If <#=code.FieldName(edmProperty)#> IsNot value Then
<#
        Else
#>
            If Not Equals(<#=code.FieldName(edmProperty)#>, value) Then
<#
        End If
#>
                OnComplexPropertyChanging()
                <#=code.FieldName(edmProperty)#> = value
                OnPropertyChanged("<#=edmProperty.Name#>")
            End If
        End Set
    End Property

    Private <#=code.FieldName(edmProperty)#> As <#=code.Escape(edmProperty.TypeUsage)#>
<#
    Next
    region.End()

    region.Begin("Propiedades complejas")
    For Each edmProperty As EdmProperty In complex.Properties.Where(Function(p) TypeOf p.TypeUsage.EdmType Is ComplexType AndAlso p.DeclaringType Is complex)
#>

    <DataMember()>
    <#=Accessibility.ForProperty(edmProperty)#> Property <#=code.Escape(edmProperty)#>() As <#=code.Escape(edmProperty.TypeUsage)#>
        <#=code.SpaceAfter(Accessibility.ForGetter(edmProperty))#>Get
            If Not <#=InitializedTrackingField(edmProperty, code)#> AndAlso <#=code.FieldName(edmProperty)#> Is Nothing Then
                <#=code.FieldName(edmProperty)#> = New <#=code.Escape(edmProperty.TypeUsage)#>()
                AddHandler DirectCast(<#=code.FieldName(edmProperty)#>, INotifyComplexPropertyChanging).ComplexPropertyChanging, AddressOf HandleComplexPropertyChanging
            End If
            <#=InitializedTrackingField(edmProperty, code)#> = True
            Return <#=code.FieldName(edmProperty)#>
        End Get
        Set(ByVal value As <#=code.Escape(edmProperty.TypeUsage)#>)
            <#=InitializedTrackingField(edmProperty, code)#> = True
            If Not Equals(<#=code.FieldName(edmProperty)#>, value) Then
                If <#=code.FieldName(edmProperty)#> IsNot Nothing Then
                    RemoveHandler DirectCast(<#=code.FieldName(edmProperty)#>, INotifyComplexPropertyChanging).ComplexPropertyChanging, AddressOf HandleComplexPropertyChanging
                End If

                OnComplexPropertyChanging()
                <#=code.FieldName(edmProperty)#> = value
                OnPropertyChanged("<#=edmProperty.Name#>")

                If value IsNot Nothing Then
                    AddHandler DirectCast(<#=code.FieldName(edmProperty)#>, INotifyComplexPropertyChanging).ComplexPropertyChanging, AddressOf HandleComplexPropertyChanging
                End If
            End If
        End Set
    End Property

    Private <#=code.FieldName(edmProperty)#> As <#=code.Escape(edmProperty.TypeUsage)#>
    Private <#=InitializedTrackingField(edmProperty, code)#> As Boolean
<#
    Next
    region.End()

    region.Begin("ChangeTracking")
#>

    Private Sub OnComplexPropertyChanging()
        RaiseEvent ComplexPropertyChanging(Me, New EventArgs())
    End Sub

    Private Event ComplexPropertyChanging As EventHandler Implements INotifyComplexPropertyChanging.ComplexPropertyChanging

    Private Sub OnPropertyChanged(ByVal propertyName As String)
        RaiseEvent PropertyChanged(Me, New PropertyChangedEventArgs(propertyName))
    End Sub

    Private Event PropertyChanged As PropertyChangedEventHandler Implements INotifyPropertyChanged.PropertyChanged
<#
    If complex.Properties.Where(Function(p) TypeOf p.TypeUsage.EdmType Is ComplexType AndAlso p.DeclaringType Is complex).Count() > 0 Then
#>

    Private Sub HandleComplexPropertyChanging(ByVal sender As Object, ByVal args As EventArgs)
        ' Enviar el evento a todas las escuchas porque algo ha cambiado en una propiedad compleja anidada
        OnComplexPropertyChanging()
    End Sub
<#
    End If
#>

    Public Shared Sub RecordComplexOriginalValues(ByVal parentPropertyName As String, ByVal complexObject As <#=code.Escape(complex)#>, ByVal changeTracker As ObjectChangeTracker)
        If String.IsNullOrEmpty(parentPropertyName) Then
            Throw New ArgumentException("El parámetro de cadena no puede ser NULL ni estar vacío.", "parentPropertyName")
        End If

        If changeTracker Is Nothing Then
            Throw New ArgumentNullException("changeTracker")
        End If
<#
        For Each complexProperty As EdmProperty in complex.Properties
            If TypeOf complexProperty.TypeUsage.EdmType Is ComplexType Then
#>
        <#=code.Escape(complexProperty.TypeUsage)#>.RecordComplexOriginalValues(String.Format(CultureInfo.InvariantCulture, "{0}.<#=complexProperty.Name#>", parentPropertyName), If(complexObject Is Nothing, Nothing, complexObject.<#=code.Escape(complexProperty)#>), changeTracker)
<#
            Else
#>
        changeTracker.RecordOriginalValue(String.Format(CultureInfo.InvariantCulture, "{0}.<#=complexProperty.Name#>", parentPropertyName), If(complexObject Is Nothing, Nothing, complexObject.<#=code.Escape(complexProperty)#>))
<#
            End If
        Next
#>
    End Sub
<#
    region.End()

#>

End Class
<#
    EndNamespace(namespaceName)
Next

If Not VerifyTypesAreCaseInsensitiveUnique(ItemCollection) Then
    Return ""
End If

fileManager.Process()
#>
<#+

Private Sub WriteHeader(ByVal fileManager As EntityFrameworkTemplateFileManager, ByVal ParamArray extraUsings As String())
    fileManager.StartHeader()
#>
'------------------------------------------------------------------------------
' <auto-generated>
'     Este código se generó a partir de una plantilla.
'
'     Los cambios en este archivo pueden ocasionar un comportamiento incorrecto y se perderán si
'     el código se vuelve a generar.
' </auto-generated>
'------------------------------------------------------------------------------

Imports System
Imports System.Collections.Generic
Imports System.Collections.ObjectModel
Imports System.Collections.Specialized
Imports System.ComponentModel
Imports System.Globalization
Imports System.Runtime.Serialization
Imports System.Runtime.CompilerServices
<#=String.Join(String.Empty, extraUsings.Select(Function(u) "Imports " & u & Environment.NewLine).ToArray())#>
<#+
    fileManager.EndBlock()
End Sub

Private Sub BeginNamespace(ByVal namespaceName As String, code As CodeGenerationTools)
    Dim region As CodeRegion = New CodeRegion(Me)
    If Not String.IsNullOrEmpty(namespaceName) Then
#>
Namespace <#=code.EscapeNamespace(namespaceName)#>
<#+
        PushIndent(CodeRegion.GetIndent(1))
    End If
End Sub

Private Sub EndNamespace(ByVal namespaceName As String)
    If Not String.IsNullOrEmpty(namespaceName) Then
        PopIndent()
#>
End Namespace
<#+
    End If
End Sub

Private Function IsReadWriteAccessibleProperty(ByVal member As EdmMember) As Boolean
    Dim setter As String = Accessibility.ForWriteOnlyProperty(member)
    Dim getter As String = Accessibility.ForReadOnlyProperty(member)

    Return getter <> "Private" AndAlso getter <> "Protected" AndAlso setter <> "Private" AndAlso setter <> "Protected"
End Function

Private Function InitializedTrackingField(ByVal edmProperty As EdmProperty, code As CodeGenerationTools) As String
    Dim namePart As String = edmProperty.Name & "Initialized"
    If code.CamelCaseFields Then
        namePart = code.CamelCase(namePart)
    End If
    Return "_" & namePart
End Function

Private Sub WriteEntityTypeSerializationInfo(ByVal type As EntityType, ByVal itemCollection As ItemCollection, ByVal code As CodeGenerationTools, ByVal tools As MetadataTools)
#>
<DataContract(IsReference:=True)>
<#+
    For Each subType As EntityType In tools.GetSubtypesOf(type, itemCollection, True)
#>
<KnownType(GetType(<#=code.Escape(subtype)#>))>
<#+
    Next
    Dim knownNavPropertyTypes As List(Of EntityType) = New List(Of EntityType)()
    For Each navProperty As NavigationProperty In type.NavigationProperties.Where(Function(np) np.DeclaringType Is type)
        Dim navPropertyType As EntityType = navProperty.ToEndMember.GetEntityType()
        If Not knownNavPropertyTypes.Contains(navPropertyType) Then
            knownNavPropertyTypes.Add(navPropertyType)
        End If
    Next
    For Each knownNavPropertyType As EntityType in knownNavPropertyTypes
#>
<KnownType(GetType(<#=code.Escape(knownNavPropertyType)#>))>
<#+
    Next
End Sub

Private Sub WriteCustomObservableCollection()
#>

' Un elemento System.Collections.ObjectModel.ObservableCollection que genera
' notificaciones de eliminación de elemento individuales al borrar e impide la adición de duplicados.
Public Class TrackableCollection(Of T)
    Inherits ObservableCollection(Of T)
    Protected Overrides Sub ClearItems()
        Dim items As New List(Of T)(Me)
        items.ForEach(Function(t) Remove(t))
    End Sub

    Protected Overloads Overrides Sub InsertItem(ByVal index As Integer, ByVal item As T)
        If Not Me.Contains(item) Then
            MyBase.InsertItem(index, item)
        End If
    End Sub
End Class
<#+
End Sub

Private Function IsSaveReference(ByVal tools as MetadataTools, ByVal navProperty As NavigationProperty) As Boolean
    ' El destino es una referencia, el origen admite valores NULL (es decir, no es PK)
    Return Not IsForeignKeyOrIdentifyingRelationship(tools, navProperty) AndAlso
            navProperty.ToEndMember.RelationshipMultiplicity <> RelationshipMultiplicity.Many AndAlso
            navProperty.FromEndMember.RelationshipMultiplicity <> RelationshipMultiplicity.One
End Function

Private Function CreateFixupMethodName(ByVal endMember As RelationshipEndMember) As String
    Return String.Format(CultureInfo.InvariantCulture, "Fixup{0}_{1}_{2}Keys", endMember.DeclaringType.NamespaceName, endMember.DeclaringType.Name, endMember.Name)
End Function

Private Function CreateKeyNameVariable(ByVal keyName As String) As String
    Return String.Format(CultureInfo.InvariantCulture, "{0}KeyName", keyName)
End Function

Private Function CreateReferenceValueLookupKey(ByVal endMember As AssociationEndMember, ByVal keyName As String) As String
    Return String.Format(CultureInfo.InvariantCulture, "Navigate({0}.{1}).{2}", endMember.DeclaringType.FullName, endMember.Name, keyName)
End Function

Private Function CreateReferenceValueLookupKey(ByVal navProp As NavigationProperty, ByVal keyName As String) As String
    Return String.Format(CultureInfo.InvariantCulture, "{0}.{1}", navProp.Name, keyName)
End Function


Private Sub WriteObjectChangeTracker()
#>
' Clase auxiliar que captura gran parte del trabajo de seguimiento de cambios que se debe realizar
' para las entidades de seguimiento propio.
<DataContract(IsReference:=True)>
Public Class ObjectChangeTracker
#Region "Campos"

    Private _isDeserializing As Boolean
    Private _objectState As ObjectState = ObjectState.Added
    Private _originalValues As OriginalValuesDictionary
    Private _extendedProperties As ExtendedPropertiesDictionary
    Private _changeTrackingEnabled As Boolean
    Private _objectsAddedToCollections As New ObjectsAddedToCollectionProperties()
    Private _objectsRemovedFromCollections As New ObjectsRemovedFromCollectionProperties()

#End Region

#Region "Eventos"

    Public Event ObjectStateChanging As EventHandler(Of ObjectStateChangingEventArgs)

#End Region

    Protected Overridable Sub OnObjectStateChanging(ByVal newState As ObjectState)
        RaiseEvent ObjectStateChanging(Me, New ObjectStateChangingEventArgs With {.NewState = newState})
    End Sub

    <DataMember()>
    Public Property State() As ObjectState
        Get
            Return _objectState
        End Get
        Set(ByVal value As ObjectState)
            If _isDeserializing Or _changeTrackingEnabled Then
                OnObjectStateChanging(value)
                _objectState = value
            End If
        End Set
    End Property

    Public Property ChangeTrackingEnabled() As Boolean
        Get
            Return _changeTrackingEnabled
        End Get
        Set(ByVal value As Boolean)
            _changeTrackingEnabled = value
        End Set
    End Property


    ' Devuelve los objetos quitados a las propiedades con valor de la colección que han cambiado.
    <DataMember()>
    Public ReadOnly Property ObjectsRemovedFromCollectionProperties() As ObjectsRemovedFromCollectionProperties
        Get
            If _objectsRemovedFromCollections Is Nothing Then
                _objectsRemovedFromCollections = New ObjectsRemovedFromCollectionProperties()
            End If
            Return _objectsRemovedFromCollections
        End Get
    End Property

    ' Devuelve los valores originales de las propiedades que han cambiado.
    <DataMember()>
    Public ReadOnly Property OriginalValues() As OriginalValuesDictionary
        Get
            If _originalValues Is Nothing Then
                _originalValues = New OriginalValuesDictionary()
            End If
            Return _originalValues
        End Get
    End Property

    ' Devuelve los valores de propiedad extendidos.
    ' Se incluyen los valores de clave para las asociaciones independientes que se necesitan para el
    ' modelo de simultaneidad en Entity Framework
    <DataMember()>
    Public ReadOnly Property ExtendedProperties() As ExtendedPropertiesDictionary
        Get
            If _extendedProperties Is Nothing Then
                _extendedProperties = New ExtendedPropertiesDictionary()
            End If
            Return _extendedProperties
        End Get
    End Property

    ' Devuelve los objetos agregados a las propiedades con valor de la colección que han cambiado.
    <DataMember()>
    Public ReadOnly Property ObjectsAddedToCollectionProperties() As ObjectsAddedToCollectionProperties
        Get
            If _objectsAddedToCollections Is Nothing Then
                _objectsAddedToCollections = New ObjectsAddedToCollectionProperties()
            End If
            Return _objectsAddedToCollections
        End Get
    End Property

#Region "MethodsForChangeTrackingOnClient"

    <OnDeserializing()>
    Public Sub OnDeserializingMethod(ByVal context As StreamingContext)
        _isDeserializing = True
    End Sub

    <OnDeserialized()>
    Public Sub OnDeserializedMethod(ByVal context As StreamingContext)
        _isDeserializing = False
    End Sub

    ' Restablece ObjectChangeTracker al estado Unchanged y
    ' borra los valores originales, así como el registro de cambios
    ' en las propiedades de la colección
    Public Sub AcceptChanges()
        OnObjectStateChanging(ObjectState.Unchanged)
        OriginalValues.Clear()
        ObjectsAddedToCollectionProperties.Clear()
        ObjectsRemovedFromCollectionProperties.Clear()
        ChangeTrackingEnabled = True
        _objectState = ObjectState.Unchanged
    End Sub

    ' Captura el valor original de una propiedad que está cambiando.
    Friend Sub RecordOriginalValue(ByVal propertyName As String, ByVal value As Object)
        If _changeTrackingEnabled AndAlso _objectState <> ObjectState.Added Then
            If Not Me.OriginalValues.ContainsKey(propertyName) Then
                OriginalValues(propertyName) = value
            End If
        End If
    End Sub

    ' Registra una adición a las propiedades con valore de la colección en las entidades SelfTracking.
    Friend Sub RecordAdditionToCollectionProperties(ByVal propertyName As String, ByVal value As Object)
        If _changeTrackingEnabled Then
            ' Agregar la entidad después de eliminarla, no se debe hacer nada aquí
            If Me.ObjectsRemovedFromCollectionProperties.ContainsKey(propertyName) AndAlso Me.ObjectsRemovedFromCollectionProperties(propertyName).Contains(value) Then
                Me.ObjectsRemovedFromCollectionProperties(propertyName).Remove(value)
                If Me.ObjectsRemovedFromCollectionProperties(propertyName).Count = 0 Then
                    Me.ObjectsRemovedFromCollectionProperties.Remove(propertyName)
                End If
                Exit Sub
            End If

            If Not Me.ObjectsAddedToCollectionProperties.ContainsKey(propertyName) Then
                ObjectsAddedToCollectionProperties(propertyName) = New ObjectList()
                ObjectsAddedToCollectionProperties(propertyName).Add(value)
            Else
                ObjectsAddedToCollectionProperties(propertyName).Add(value)
            End If
        End If
    End Sub

    ' Registra una eliminación a las propiedades con valor de la colección en las entidades SelfTracking.
    Friend Sub RecordRemovalFromCollectionProperties(ByVal propertyName As String, ByVal value As Object)
        If _changeTrackingEnabled Then
            ' Eliminar la entidad después de agregarla, no se debe hacer nada aquí
            If Me.ObjectsAddedToCollectionProperties.ContainsKey(propertyName) AndAlso Me.ObjectsAddedToCollectionProperties(propertyName).Contains(value) Then
                Me.ObjectsAddedToCollectionProperties(propertyName).Remove(value)
                If Me.ObjectsAddedToCollectionProperties(propertyName).Count = 0 Then
                    Me.ObjectsAddedToCollectionProperties.Remove(propertyName)
                End If
                Exit Sub
            End If

            If Not Me.ObjectsRemovedFromCollectionProperties.ContainsKey(propertyName) Then
                ObjectsRemovedFromCollectionProperties(propertyName) = New ObjectList()
                ObjectsRemovedFromCollectionProperties(propertyName).Add(value)
            Else
                If Not ObjectsRemovedFromCollectionProperties(propertyName).Contains(value) Then
                    ObjectsRemovedFromCollectionProperties(propertyName).Add(value)
                End If
            End If
        End If
    End Sub
#End Region
End Class

#Region "EnumForObjectState"
<Flags()>
Public Enum ObjectState
    Unchanged = &H1
    Added = &H2
    Modified = &H4
    Deleted = &H8
End Enum
#End Region

<CollectionDataContract(Name:="ObjectsAddedToCollectionProperties", ItemName:="AddedObjectsForProperty", KeyName:="CollectionPropertyName", ValueName:="AddedObjects")>
Public Class ObjectsAddedToCollectionProperties
    Inherits Dictionary(Of String, ObjectList)
End Class

<CollectionDataContract(Name:="ObjectsRemovedFromCollectionProperties", ItemName:="DeletedObjectsForProperty", KeyName:="CollectionPropertyName", ValueName:="DeletedObjects")>
Public Class ObjectsRemovedFromCollectionProperties
    Inherits Dictionary(Of String, ObjectList)
End Class

<CollectionDataContract(Name:="OriginalValuesDictionary", ItemName:="OriginalValueForProperty", KeyName:="ReferencePropertyName", ValueName:="OriginalValue")>
Public Class OriginalValuesDictionary
    Inherits Dictionary(Of String, Object)
End Class

<CollectionDataContract(Name:="ExtendedPropertiesDictionary", ItemName:="ExtendedProperties", KeyName:="Name", ValueName:="ExtendedProperty")>
Public Class ExtendedPropertiesDictionary
    Inherits Dictionary(Of String, Object)
End Class

<CollectionDataContract(ItemName:="ObjectValue")>
Public Class ObjectList
    Inherits List(Of Object)
End Class
<#+
End Sub

Private Sub WriteINotifyComplexPropertyChanging()
#>

' Una interfaz que proporciona un evento que se activa cuando cambian las propiedades complejas.
' Los cambios pueden ser el reemplazo de una propiedad compleja por una nueva instancia de tipo complejo o
' un cambio en una propiedad escalar en una instancia de tipo complejo.
Public Interface INotifyComplexPropertyChanging
    Event ComplexPropertyChanging As EventHandler
End Interface
<#+
End Sub

Private Sub WriteIObjectWithChangeTracker()
#>
' La interfaz se implementa mediante las entidades de seguimiento propio que generará EF.
' Habrá un adaptador que convierte esta interfaz en la que espera EF.
' El adaptador estará en el servidor.
Public Interface IObjectWithChangeTracker
    ' Tiene toda la información de seguimiento de cambios para el subgráfico de un determinado objeto.
    Property ChangeTracker() As ObjectChangeTracker
End Interface

Public Class ObjectStateChangingEventArgs
    Inherits EventArgs
    Private _NewState As ObjectState
    Public Property NewState() As ObjectState
        Get
            Return _NewState
        End Get
        Set(ByVal value As ObjectState)
            _NewState = value
        End Set
    End Property
End Class

Public Module ObjectWithChangeTrackerExtensions
    <Extension()>
    Public Function MarkAsDeleted(Of T As IObjectWithChangeTracker)(ByVal trackingItem As T) As T
        If trackingItem Is Nothing Then
            Throw New ArgumentNullException("trackingItem")
        End If

        trackingItem.ChangeTracker.ChangeTrackingEnabled = True
        trackingItem.ChangeTracker.State = ObjectState.Deleted
        Return trackingItem
    End Function

    <Extension()>
    Public Function MarkAsAdded(Of T As IObjectWithChangeTracker)(ByVal trackingItem As T) As T
        If trackingItem Is Nothing Then
            Throw New ArgumentNullException("trackingItem")
        End If

        trackingItem.ChangeTracker.ChangeTrackingEnabled = True
        trackingItem.ChangeTracker.State = ObjectState.Added
        Return trackingItem
    End Function

    <Extension()>
    Public Function MarkAsModified(Of T As IObjectWithChangeTracker)(ByVal trackingItem As T) As T
        If trackingItem Is Nothing Then
            Throw New ArgumentNullException("trackingItem")
        End If

        trackingItem.ChangeTracker.ChangeTrackingEnabled = True
        trackingItem.ChangeTracker.State = ObjectState.Modified
        Return trackingItem
    End Function

    <Extension()>
    Public Function MarkAsUnchanged(Of T As IObjectWithChangeTracker)(ByVal trackingItem As T) As T
        If trackingItem Is Nothing Then
            Throw New ArgumentNullException("trackingItem")
        End If

        trackingItem.ChangeTracker.ChangeTrackingEnabled = True
        trackingItem.ChangeTracker.State = ObjectState.Unchanged
        Return trackingItem
    End Function

    <Extension()>
    Public Sub StartTracking(ByVal trackingItem As IObjectWithChangeTracker)
        If trackingItem Is Nothing Then
            Throw New ArgumentNullException("trackingItem")
        End If

        trackingItem.ChangeTracker.ChangeTrackingEnabled = True
    End Sub

    <Extension()>
    Public Sub StopTracking(ByVal trackingItem As IObjectWithChangeTracker)
        If trackingItem Is Nothing Then
            Throw New ArgumentNullException("trackingItem")
        End If

        trackingItem.ChangeTracker.ChangeTrackingEnabled = False
    End Sub

    <Extension()>
    Public Sub AcceptChanges(ByVal trackingItem As IObjectWithChangeTracker)
        If trackingItem Is Nothing Then
            Throw New ArgumentNullException("trackingItem")
        End If

        trackingItem.ChangeTracker.AcceptChanges()
    End Sub
End Module
<#+
End Sub

Private Sub WriteEqualityComparer
#>
Public Module EqualityComparer
    ' Método auxiliar para determinar si dos matrices de bytes son el mismo valor incluso si son referencias de objeto diferentes
    Public Function BinaryEquals(ByVal binaryValue1 As Object, ByVal binaryValue2 As Object) As Boolean
        If Object.ReferenceEquals(binaryValue1, binaryValue2) Then
            Return True
        End If

        Dim array1 As Byte() = TryCast(binaryValue1, Byte())
        Dim array2 As Byte() = TryCast(binaryValue2, Byte())

        If array1 IsNot Nothing AndAlso array2 IsNot Nothing Then
            If array1.Length <> array2.Length Then
                Return False
            End If

            For i As Integer = 0 To array1.Length - 1
                If array1(i) <> array2(i) Then
                    Return False
                End If
            Next

            Return True
        End If

        Return False
    End Function
End Module
<#+
End Sub

Private Function InheritanceOperator(ByVal entity As StructuralType) As String
    If entity.BaseType Is Nothing Then
        Return "Overridable "
    Else
        Return "Overloads Overrides "
    End If
End Function

Private Function VerifyTypesAreCaseInsensitiveUnique(ByVal itemCollection As EdmItemCollection) As Boolean
    Dim alreadySeen As New Dictionary(Of String, Boolean)(StringComparer.OrdinalIgnoreCase)

    For Each type As StructuralType In itemCollection.GetItems(Of StructuralType)()
        If Not (TypeOf type Is EntityType OrElse TypeOf type Is ComplexType) Then
            Continue For
        End If

        If alreadySeen.ContainsKey(type.FullName) Then
            [Error](String.Format(CultureInfo.CurrentCulture, "Esta plantilla no admite los tipos que solo difieren en las mayúsculas y minúsculas, los tipos {0} no se admiten", type.FullName))
            Return False
        Else
            alreadySeen.Add(type.FullName, True)
        End If
    Next

    Return True
End Function

' True si la asociación para la propiedad de navegación especificada es una relación de identificación o una relación de clave externa.
Private Function IsForeignKeyOrIdentifyingRelationship(ByVal tools As MetadataTools, ByVal navProperty As NavigationProperty) As Boolean
    If tools Is Nothing Then
        Throw New ArgumentNullException("tools")
    End If

    If navProperty Is Nothing Then
        Throw New ArgumentNullException("navProperty")
    End If

    Return IsForeignKeyOrIdentifyingRelationship(tools, DirectCast(navProperty.RelationshipType, AssociationType))
End Function

' True si la asociación especificada es una relación de identificación o una relación de clave externa.
Private Function IsForeignKeyOrIdentifyingRelationship(ByVal tools As MetadataTools, ByVal association As AssociationType) As Boolean
    If tools Is Nothing Then
        Throw New ArgumentNullException("tools")
    End If

    If association Is Nothing Then
        Throw New ArgumentNullException("association")
    End If

    Return association.IsForeignKey OrElse tools.IsIdentifyingRelationship(association)
End Function

' Establecer recordRequiredOriginalValuesOnly en false en el constructor OriginalValueMembers para registrar siempre todos los valores originales.
Public Class OriginalValueMembers
    Private ReadOnly _concurrencyMembers As HashSet(Of EdmProperty)

    Public Sub New(ByVal recordRequiredOriginalValuesOnly As Boolean, ByVal metadataWorkspace As MetadataWorkspace, ByVal metadataTools As MetadataTools)
        If recordRequiredOriginalValuesOnly Then
            Try
                _concurrencyMembers = New HashSet(Of EdmProperty)()
                For Each container As EntityContainer In metadataWorkspace.GetItems(Of EntityContainer)(DataSpace.CSpace)
                    Dim directSubTypeLookup As ILookup(Of EntityType, EntityType) = metadataWorkspace.GetItems(Of EntityType)(DataSpace.CSpace).ToLookup(Function(e) DirectCast(e.BaseType, EntityType))
                    For Each eSet As EntitySetBase In container.BaseEntitySets.Where(Function(es) es.BuiltInTypeKind = BuiltInTypeKind.EntitySet)
                        Dim subTypes As New List(Of EntityType)()
                        GetSubtypes(directSubTypeLookup, DirectCast(eSet.ElementType, EntityType), subTypes)
                        For Each eType As EntityType In subTypes
                            For Each member As EdmProperty In metadataWorkspace.GetRequiredOriginalValueMembers(eSet, eType)
                                _concurrencyMembers.Add(member)
                            Next
                        Next
                    Next
                Next

                ' GetRequiredOriginalValueMembers no siempre devolverán propiedades de clave externa, pero es obligatorio
                For Each assoc As AssociationType In metadataWorkspace.GetItems(Of AssociationType)(DataSpace.CSpace).Where(Function(a) a.IsForeignKey)
                    For Each toProperty As EdmProperty In assoc.ReferentialConstraints(0).ToProperties
                        _concurrencyMembers.Add(toProperty)
                    Next
                Next
            Catch ex As Exception
                ' Si se producen excepciones, retroceder siempre a los valores originales registrados para todas las propiedades
                _concurrencyMembers = Nothing
            End Try
        End If
    End Sub

    Public Function IsOriginalValueMember(ByVal edmProperty As EdmProperty) As Boolean
        Return _concurrencyMembers Is Nothing OrElse _concurrencyMembers.Contains(edmProperty)
    End Function

    Private Shared Sub GetSubtypes(ByVal lookup As ILookup(Of EntityType, EntityType), ByVal eType As EntityType, ByVal subTypes As List(Of EntityType))
        subTypes.Add(eType)
        For Each subType As EntityType In lookup(eType)
            GetSubtypes(lookup, subType, subTypes)
        Next
    End Sub
End Class
#>
